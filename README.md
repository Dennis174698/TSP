
## Applying Ant Colony Optimisation to the Travelling Salesman Problem

### problem discription 
Travelling salesman problem:if a travelling salesman wishes to visit exactly once each of a list of m cities (where the cost of travelling from city i to city j is cij) and then return to the home city, what is the least costly route a salesman can take?

### Algorithm
[Ant Colony Optimisation](https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms )<br>
<img align="middle" src="https://github.com/Dennis174698/TSP/raw/master/aco.png"  > <br>
The ACO algorithm is based on the behaviour of ants, attempts to find the optimal path between two points.<br>
This is achieved by sending a number of waves of ants to traverse the graph. The first wave of ants traverse the graph either randomly or based on a simple heuristic approach (such as taking the shortest path from any node).<br>
Pheromone is then distributed along successful paths such that the paths determined to be better by a scoring function will receive a higher amount of pheromone. Further generations of ants are then sent to traverse the graph, taking into account pheromone levels and heuristic, and again laying pheromone on paths proportionally to the paths score. <br>
In this way, the most optimal paths will accumulate the highest amounts of pheromone and are more likely to be chosen by subsequent generations of ants. <br>


### Implementation
<img align="left" src="https://github.com/Dennis174698/TSP/raw/master/workflow1.png" height="646px" > 
  The iterations stage involves iterating through a set number of generations, and performing the following operations in each   iteration:   <br>
  1. Generating a route for each ant. This route is generated by: <br>
  a. Randomly choosing a starting location <br>
  b. Selecting the next location to visit based on a combination of the pheromone map and the heuristic factor. Specifically, each unvisited location is given a score using the following formula:  <br>
  
  `ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’ = ğ‘â„ğ‘’ğ‘Ÿğ‘œğ‘šğ‘œğ‘›ğ‘’ğ›¼**Î± âˆ— â„ğ‘’ğ‘¢ğ‘Ÿğ‘–ğ‘ ğ‘¡ğ‘–ğ‘**Î² `<br>
  `P[i]=(Tau[currNode,tempnextnode]**alpha)*(Eta[currNode,tempnextnode]**beta)`<br>
  
  
   Where:  `ğ‘â„ğ‘’ğ‘Ÿğ‘œğ‘šğ‘œğ‘›ğ‘’` = Quantity of pheromone on the path from the current location to the unvisited location.<br>
   `Î±` = Scaling factor for the impact of pheromone weights.  <br>
   `â„ğ‘’ğ‘¢ğ‘Ÿğ‘–ğ‘ ğ‘¡ğ‘–ğ‘` = heuristic value (in this solution 1/distance) from the current location to the unvisited location.<br>
   `Î²` = Scaling factor for the impact of the heuristic information.<br>
   c. Adding the next location to the route and removing it from the list of unvisited locations.<br>
   2. Scoring the route based on the total distance travelled to traverse it.`(cost= fun.decodingFun(RouteData,popsize,dmat,N))`<br>
   3. Update the best found solution if any of the new solutions are improvements.<br>
   4. Normalise the scores into the range [100, 200].<br>
   5. Generate a map of pheromone to be distributed along the routes of the ants. This value is determined by `ğ‘ / ğ‘ ğ‘ğ‘ğ‘™ğ‘’ğ‘‘ ğ‘ ğ‘ğ‘œğ‘Ÿğ‘’`pheromone to each path on the route, where q is some scaling factor.<br>
   6.Decay the existing pheromone and add the required new pheromone using the following equation:<br>
`ğ‘â„ğ‘’ğ‘Ÿğ‘œğ‘šğ‘œğ‘›ğ‘’ = ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘ƒâ„ğ‘’ğ‘Ÿğ‘œğ‘šğ‘œğ‘›ğ‘’ âˆ— (1 âˆ’ â´) + ğ‘›ğ‘’ğ‘¤ğ‘ƒâ„ğ‘’ğ‘Ÿğ‘œğ‘šğ‘œğ‘›ğ‘’(Tau=Tau*(1-rho)+detaTau)`<br>
Where:<br>
`ğ‘â„ğ‘’ğ‘Ÿğ‘œğ‘šğ‘œğ‘›ğ‘’` = Updated pheromone value for the path.<br>
`ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ğ‘ƒâ„ğ‘’ğ‘Ÿğ‘œğ‘šğ‘œğ‘›ğ‘’` = Pheromone currently on the path.<br>
`â´ = Pheromone decay constant`.<br>
`ğ‘›ğ‘’ğ‘¤ğ‘ƒâ„ğ‘’ğ‘Ÿğ‘œğ‘šğ‘œğ‘›ğ‘’` = Pheromone to be added based on the route score.<br>


 
